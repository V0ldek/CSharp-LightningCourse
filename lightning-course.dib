#!markdown

# Lightning course in C#

<small>Copyright (c) Mateusz Gienieczko 2021</small>

Przeczytaj wstp tutaj: https://mimuw.edu.pl/~mg394302/bd2021-csharp.html.

#!markdown

<h2 id="toc">Table of Contents</h2>

ToC jest zbugowana, bo VS Code nie indeksuje caego notebooka na raz, wic nie ma pojcia, 偶e te odnoniki si do czego odnosz. Bardzo smutne.

0. <a href="#co-to-c--">Co to C#?</a>
1. <a href="#jak-dzia-a-c--">Jak dziaa C#?</a>
<br>
    1.0 <a href="#klasyka-gatunku">Klasyka gatunku</a>
<br>
    1.1 <a href="#desugarisation">Desugarisation</a>
<br>
    1.2 <a href="#using-directives">Using directives</a>
<br>
    1.3 <a href="#podstawowe-typy">Podstawowe typy</a>
<br>
    1.4 <a href="#keyword--var-">Keyword `var`</a>
<br>
    1.5 <a href="#p-tla--foreach-">Ptla `foreach`</a>
<br>
    1.6 <a href="#access-specifiers">Access specifiers</a>
<br>
    1.7 <a href="#fields">Fields</a>
<br>
    1.8 <a href="#properties">Properties</a>
<br>
    1.9 <a href="#metody">Metody</a>
<br>
    1.10 <a href="#interfejsy">Interfejsy</a>
<br>
    1.11 <a href="#dziedziczenie">Dziedziczenie</a>
<br>
    1.12 <a href="#przeci--anie">Przeci偶anie</a>
<br>
    1.13 <a href="#prze-adowywanie--overriding-">Przeadowywanie (overriding)</a>
<br>
    1.14 <a href="#konstruktory">Konstruktory</a>
<br>
    1.15 <a href="#keyword--init-">Keyword `init`</a>
<br>
    1.16 <a href="#sealed">Sealed</a>
<br>
    1.17 <a href="#klasy-abstrakcyjne">Klasy abstrakcyjne</a>
<br>
    1.18 <a href="#enums">Enums</a>
<br>
    1.19 <a href="#reference-types-vs-value-types">Reference types vs Value types</a>
<br>
    1.20 <a href="#nullability">Nullability</a>
<br>
    1.21 <a href="#parametry--ref--i--out-">Parametry `ref` i `out`</a>
<br>
    1.22 <a href="#r-wno--">R贸wno</a>
<br>
    1.23 <a href="#parse-i-tryparse">Parse i TryParse</a>
<br>
    1.24 <a href="#generics">Generics</a>
<br>
    1.25 <a href="#generic-constraints">Generic constraints</a>
<br>
    1.26 <a href="#kolekcje">Kolekcje</a>
<br>
    1.27 <a href="#stringi">Stringi</a>
<br>
    1.28 <a href="#statyczne-klasy">Statyczne klasy</a>
<br>
    1.29 <a href="#extension-methods">Extension methods</a>
<br>
    1.30 <a href="#operatory">Operatory</a>
<br>
    1.31 <a href="#rzutowanie">Rzutowanie</a>
<br>
    1.32 <a href="#boxing">Boxing</a>
<br>
    1.33 <a href="#przeci--anie-operator-w">Przeci偶anie operator贸w</a>
<br>
    1.34 <a href="#indekser">Indekser</a>
<br>
    1.35 <a href="#tuples--valuetuple-">Tuples (ValueTuple)</a>
<br>
    1.36 <a href="#wyj-tki">Wyjtki</a>
<br>
    1.37 <a href="#garbage-collector">Garbage collector</a>
<br>
    1.38 <a href="#dispose">Dispose</a>
<br>
    1.39 <a href="#atrybuty">Atrybuty</a>
<br>
    1.40 <a href="#-nameof-">`nameof`</a>
<br>
    1.41 <a href="#anonimowe-obiekty">Anonimowe obiekty</a>
<br>
    1.42 <a href="#delegates">Delegates</a>
<br>
    1.43 <a href="#lambdy">Lambdy</a>
<br>
    1.44 <a href="#lokalne-metody">Lokalne metody</a>
<br>
    1.45 <a href="#-linq"> LINQ</a>
<br>
    1.46 <a href="#-select----projekcja">`Select` - projekcja</a>
<br>
    1.47 <a href="#-where----selekcja-filtrowanie">`Where` - selekcja/filtrowanie</a>
<br>
    1.48 <a href="#-orderby----thenby----sortowanie">`OrderBy`, `ThenBy` - sortowanie</a>
<br>
    1.49 <a href="#-query-syntax"> Query syntax</a>
<br>
    1.50 <a href="#-selectmany----sp-aszczenie">`SelectMany` - spaszczenie</a>
<br>
    1.51 <a href="#-groupby----grupowanie">`GroupBy` - grupowanie</a>
<br>
    1.52 <a href="#-join-">`Join`</a>
<br>
    1.53 <a href="#inne">Inne</a>
<br>
    1.54 <a href="#deferred-execution">Deferred execution</a>
<br>
    1.55 <a href="#-tolist----execute-">`ToList` - execute!</a>
<br>
    1.56 <a href="#agregacje">Agregacje</a>
<br>
    1.57 <a href="#-first----last----single-">`First`, `Last`, `Single`</a>
<br>
    1.58 <a href="#-count-">`Count`</a>
<br>
    1.59 <a href="#-all----any-">`All`, `Any`</a>
2. <a href="#materia-y">Materiay</a>

#!markdown

<h2 id="co-to-c--">0. Co to C#?</h2> <small><a href="#toc">Back to top</a></small>

**C# (obecnie 10)** &ndash; jzyk zaprojektowany w 2000 przez Andersa Hejlsberga dla Microsoftu.

**.NET** (obecnie 6) &ndash; wielki framework i biblioteka standardowa do jzyk贸w uruchamianych pod CLR, w tym C#.

**Roslyn** &ndash; g贸wna implementacja kompilatora do C#, utrzymywana i rozwijana przez community i Microsoft.
**CLI (Common Language Infrastructure)** &ndash; specyfikacja rodowiska i bytecodeu do uruchamiania midzy innymi C#. Taka lepsza JVM.
**CLR (Common Language Runtime)** &ndash; g贸wna implementacja CLI.

#!markdown

<h2 id="jak-dzia-a-c--">1. Jak dziaa C#?</h2> <small><a href="#toc">Back to top</a></small>

C# jest **obiektowym**, **statycznie typowanym**, **kompilowanym** jzykiem. Ma te偶 najdu偶sz list obejmowanych paradygmat贸w jak widziaem na Wikipedii. 
> structured, imperative, object-oriented, event-driven, task-driven, functional, generic, reflective, concurrent

It truly embraces the _general purpose_ label.
 
C# jest zorientowany na bezpieczestwo i wygod developera. 
- Memory safety
- Type safety
- Nie krzyczymy na jzyk, 偶e jest gupi (por. Java)
- Jzyk nie krzyczy na nas, 偶e jestemy gupi (por. C++)

Nawet wtedy pozwala nam porzuci granice zdrowego rozsdku i udostpnia typowanie dynamiczne (`dynamic`) oraz magiczny keyword `unsafe`, kt贸ry wycza memory safety. Tutaj nie bdziemy si nimi zajmowa.

#!markdown

<h3 id="klasyka-gatunku">1.0 Klasyka gatunku</h3> <small><a href="#toc">Back to top</a></small>

#!csharp

Console.WriteLine("Hello, World!");

#!markdown

Nazwy klas i metod piszemy CamelCasem.

#!markdown

<h3 id="desugarisation">1.1 Desugarisation</h3> <small><a href="#toc">Back to top</a></small>

#!csharp

namespace SeeITSharp;

public class HelloWorld
{
    public static void Main()
    {
        System.Console.WriteLine("Hello World!");
    }
}

#!markdown

- Namespace'y grupuj powizane ze sob typy.
- Obiektowo &ndash; ka偶da metoda nale偶y do jakiej klasy.

#!markdown

<h3 id="using-directives">1.2 Using directives</h3> <small><a href="#toc">Back to top</a></small>

#!csharp

using System;

namespace SeeITSharp;

public class HelloWorld
{
    public static void Main()
    {
        Console.WriteLine("Hello World!");
    }
}

#!markdown

- Jeli czsto u偶ywamy danego namespace'a to mo偶na go wprowadzi u偶ywajc `using`.
- Domylnie wprowadzone s podstawowe namespace'y .NET-a.
- No "import hell."

Jak wida po errorach, skryptowa natura notebook贸w nie lubi si z deklaracjami namespace'贸w i explicit `Main`-em, wic bdziemy pomija t ceremoni.

#!markdown

<h3 id="podstawowe-typy">1.3 Podstawowe typy</h3> <small><a href="#toc">Back to top</a></small>

Podstawowe funkcjonalnoci jzyka s podobne jak w Javie.  Mamy gar typ贸w wbudowanych :
- `bool` - `true`, `false`;
- `byte` - 8 bit贸w;
- `char` - 16 bit贸w do przechowywania znaku w Unicode;
- `decimal` - 128 bit贸w z wysok precyzj np. `1234.5678m`;
- `double` - 64 bity, double precision floating point np. `1234.5678`;
- `float` - 32 bity floating point np. `1234.5678f`;
- `int` - 32 bity ze znakiem;
- `long` - 64 bity ze znakiem;
- `object` - korze hierarchii dziedziczenia wszystkich typ贸w
- `string` - napis.

Mamy te偶 tablice:

#!csharp

int[] tab = new int[16];

for (int i = 0; i < tab.Length; ++i)
{
    tab[i] = i;
}

for (int i = 0; i < tab.Length; ++i)
{
    Console.Write(i.ToString() + " ");
}
Console.WriteLine();

#!markdown

Wielowymiarowe tablice deklarujemy jako tablice tablic :

#!csharp

int[][] jagged = new int[4][];
for(int i = 0; i < jagged.Length; ++i)
{
    jagged[i] = new int[i + 1];
}

jagged[1][1] = 1;

Console.WriteLine(jagged[1][1]);

#!markdown

<h3 id="keyword--var-">1.4 Keyword `var`</h3> <small><a href="#toc">Back to top</a></small>

C# jest statycznie typowany, ale niekoniecznie explicitly typowany. Posiada local variable type inference, tzn. kompilator jest w stanie wywnioskowa typ deklaracji na podstawie przypisania.

#!csharp

int i = 3;

#!csharp

var i = 3;

#!csharp

var line = i.ToString(); // Variable line is a string.

#!markdown

R贸偶ne konwencje:
- Nie u偶ywa `var` (gupie)
- U偶ywa `var` "gdy typ jest oczywisty"
- U偶ywa `var` zawsze, gdy mo偶na

Dla cel贸w dydaktycznych bd stosowa konwencj 2 w tej prezentacji. Generalnie ludzko dosza ju偶 do wniosku, 偶e z reguy to kompilator powinien przejmowa si wymylaniem typ贸w, dlatego w nowych jzykach, takich jak Rust, wszystkie deklaracje s implicitly typed by default.

#!markdown

<h3 id="p-tla--foreach-">1.5 Ptla `foreach`</h3> <small><a href="#toc">Back to top</a></small>

Do iterowania si po tablicach, (dokadniej po `IEnumerable`, o kt贸rym p贸藕niej), w wikszoci przypadk贸w u偶ywa si ptli `foreach`.

#!csharp

int[] tab = new int[16];

for (int i = 0; i < tab.Length; ++i)
{
    tab[i] = i;
}

foreach(var i in tab)
{
    Console.Write(i.ToString() + " ");
}

Console.WriteLine();

#!markdown

<h3 id="access-specifiers">1.6 Access specifiers</h3> <small><a href="#toc">Back to top</a></small>
Zajmijmy si w kocu klasami. W C# mamy cztery access specifiery.
- `public` - widoczne wszdzie (jak w Javie)
- `internal` - widoczne w obrbie tego assembly (podobne do package-private w Javie)
- `protected` - widoczne dla mnie i wszystkiego, co po mnie dziedziczy (jak w Javie)
- `private` - widoczne dla mnie i tylko dla mnie (jak w Javie)

#!markdown

<h3 id="fields">1.7 Fields</h3> <small><a href="#toc">Back to top</a></small>

Pola wewntrz klasy deklaruje si jak w Javie.

#!csharp

public class Duck
{
    private int _timesSqueaked = 0;
    private readonly string _name;
}

#!markdown

Pola mog mie domylne wartoci, tak jak wy偶ej.

Mog one mie nastpujce modyfikatory .
- `readonly` - to pole mo偶e by ustawione tylko przez domyln warto lub konstruktor
- `const` - compile-time constant
- `static` - pole statyczne, nieprzypisane do 偶adnej instancji

Niestatyczne pola powinny by prywatne. Jak nie s prywatne, to pewnie co poszo nie tak przy projektowaniu klasy.

Popularn konwencj nazewnictwa (i zalecan przez MSDN) jest pisanie prywatnych p贸l _camelCasem (zaczynanym od podogi), aczkolwiek spotyka si te偶 zwyky camelCase. Stae piszemy PascalCasem.

#!markdown

<h3 id="properties">1.8 Properties</h3> <small><a href="#toc">Back to top</a></small>
Skoro pola s prywatne, to potrzebujemy getter贸w i setter贸w.

#!csharp

private int _timesSqueaked = 0;

public int TimesSqueaked
{
    get
    {
        return _timesSqueaked;
    }
    set
    {
        _timesSqueaked = value;
    }
}

#!markdown

Oczywicie tyle linii kodu to sroga przesada, ale da si to zbi u偶ywajc expression bodies.

#!csharp

private int _timesSqueaked = 0;

public int TimesSqueaked
{
    get => _timesSqueaked;
    set => _timesSqueaked = value;
}

#!markdown

Tw贸rcy C# zauwa偶yli, 偶e po pierwsze, najczciej nazwy property bd takie same jak ich odpowiadajcych p贸l (tylko wielk liter), a po drugie najczciej getter i setter jest domylny, get zwraca, set przypisuje. Dlatego da si napisa te偶 tak:

#!csharp

public int TimesSqueaked { get; set; }

#!markdown

Oraz doda domyln warto:

#!csharp

public int TimesSqueaked { get; set; } = 0;

#!markdown

Ta linijka jest r贸wnowa偶na tym wy偶ej. Mo偶emy nawet nada r贸偶ne access specifiery:

#!csharp

public int TimesSqueaked { get; private set; } = 0;

#!markdown

Domylnie jest taki sam jak samej property. Odwoywanie si do property jest bardzo proste:

#!csharp

public class Duck
{
    public int TimesSqueaked { get; set; }
}

var duck = new Duck();
duck.TimesSqueaked = 42; // Calls the set method.
Console.WriteLine(duck.TimesSqueaked); // Calls the get method.

#!markdown

Jeli property ma tylko getter i jest on jednolinijkowy, mo偶na zastosowa nawet bardziej zwiz notacj:

#!csharp

public class Duck
{
    public int Sum { get; set; }
    public int Number { get; set; }
    public float AverageValue => (float) Sum / Number;
}

var duck = new Duck();
duck.Sum = 42;
duck.Number = 9;
Console.WriteLine(duck.AverageValue);

#!markdown

<h3 id="metody">1.9 Metody</h3> <small><a href="#toc">Back to top</a></small>

Jakie metody s, ka偶dy widzi. Deklarujemy typ zwracany i przyjmowane argumenty. Do instancji, na kt贸rej wywoano metod, mo偶emy si odwoa za pomoc `this`.

#!csharp

public class Duck
{
    public int TimesSqueaked { get; set; }

    public void Squeak(string message)
    {
        Console.WriteLine("Squeak! " + message);
        this.TimesSqueaked++;  // This `this` is actually redundant.
    }
}

var duck = new Duck();
Console.WriteLine(duck.TimesSqueaked);
duck.Squeak("Hello, World!");
Console.WriteLine(duck.TimesSqueaked);

#!markdown

Getter i setter property to penoprawne metody i mog zawiera dowoln logik. Konwencjonalnie jednak nie powinny by bardzo zasobo偶erne.

#!csharp

public class Duck
{
    private int _timesSqueaked;
    public int TimesSqueaked 
    { 
        get => _timesSqueaked;
        set => _timesSqueaked = Math.Max(value, 0); 
    }
}

var duck = new Duck();
duck.TimesSqueaked = 17;
Console.WriteLine(duck.TimesSqueaked);
duck.TimesSqueaked = -8;
Console.WriteLine(duck.TimesSqueaked);

#!markdown

<h3 id="interfejsy">1.10 Interfejsy</h3> <small><a href="#toc">Back to top</a></small>

Interfejsy mog zawiera tylko deklaracje publicznych metod . Gettery i settery to metody:

#!csharp

public interface IDuck
{
   int TimesSqueaked { get; }
   void Squeak();
}

#!markdown

Klasa mo偶e implementowa dowolnie wiele interfejs贸w. Aby implementowa interfejs nale偶y dostarczy publiczne metody o podanych sygnaturach.

#!csharp

public class Duck : IDuck
{
    public int TimesSqueaked { get; }
    public void Squeak() { }
}

#!markdown

<h3 id="dziedziczenie">1.11 Dziedziczenie</h3> <small><a href="#toc">Back to top</a></small>

Klasy mog dziedziczy po maksymalnie jednej innej klasie i implementowa dowolnie wiele interfejs贸w. Klasy dziedzicz wszystkie metody, pola etc.
Ka偶da klasa dziedziczy domylnie po `System.Object`.

#!csharp

public class Duck
{
    public void Squeak() => Console.WriteLine("Squeak!");
}

public class BetterDuck : Duck
{
}

BetterDuck duck = new BetterDuck();
duck.Squeak();

#!markdown

<h3 id="przeci--anie">1.12 Przeci偶anie</h3> <small><a href="#toc">Back to top</a></small>

Metody mo偶na przeci偶a, t.j. deklarowa dwie metody o tej samej nazwie, ale z innymi parametrami i/lub z innym typem zwracanym. Kompilator wybierze najlepiej pasujc metod at compile time.

#!csharp

public void SqueakADuck(Duck duck) => 
    Console.WriteLine("Squeak!");

public void SqueakADuck(BetterDuck duck) => 
    Console.WriteLine("Better squeak!");

Duck duck = new Duck();
BetterDuck betterDuck = new BetterDuck();
Duck betterDuckDisguisedAsANormalDuck = new BetterDuck();

SqueakADuck(duck);
SqueakADuck(betterDuck);
SqueakADuck(betterDuckDisguisedAsANormalDuck);

#!markdown

<h3 id="prze-adowywanie--overriding-">1.13 Przeadowywanie (overriding)</h3> <small><a href="#toc">Back to top</a></small>

Metody mo偶na przeadowywa (override'owa), ale tylko jeli w klasie bazowej byy zadeklarowane jako `virtual`. Trzeba to zaznaczy za pomoc `override`. Oczywicie mamy polimorfizm.

#!csharp

public class Duck
{
    public virtual void Squeak() =>
        Console.WriteLine("Squeak!");
}

public class BetterDuck : Duck
{
    public override void Squeak() =>
        Console.WriteLine("Better squeak!");
}

Duck duck = new Duck();
BetterDuck betterDuck = new BetterDuck();
Duck betterDuckDisguisedAsANormalDuck = new BetterDuck();

duck.Squeak();
betterDuck.Squeak();
betterDuckDisguisedAsANormalDuck.Squeak();

#!markdown

Mo偶e si zdarzy, 偶e chcemy wywoa implementacj z klasy bazowej. Su偶y do tego keyword `base`.

#!csharp

public class BetterDuck : Duck
{
    public override void Squeak()
    {
        Console.WriteLine("Better squeak!");
        base.Squeak();
    }
}

var betterDuck = new BetterDuck();
betterDuck.Squeak();

#!markdown

<h3 id="konstruktory">1.14 Konstruktory</h3> <small><a href="#toc">Back to top</a></small>

W skr贸cie ctor, su偶y do tworzenia obiekt贸w klasy za pomoc `new`.

#!csharp

public class Duck
{
    public string Name { get; }
    
    public Duck(string name) => Name = name;
}

var duck = new Duck("Jacu");

Console.WriteLine(duck.Name);

#!markdown

Jeli nie podamy 偶adnego, C# stworzy dla nas domylny:

#!csharp

public class Duck
{
    public Duck() : base()
    {
    }
}

#!markdown

Konstruktor podklasy musi wywoa jaki konstruktor klasy bazowej, domylnie bezparametrowy.
Mo偶emy te偶 wywoa inny konstruktor z konstruktora za pomoc `this`.

#!csharp

public class Duck
{
    public string Name { get; }

    public Duck() : this("Jacu")
    {
    }

    public Duck(string name) => Name = name;
}

var defaultDuck = new Duck();
var piotruDuck = new Duck("Piotru");

Console.WriteLine(defaultDuck.Name);
Console.WriteLine(piotruDuck.Name);

#!markdown

Jeli mamy bezparametrowy ctor i settery, mo偶emy zainicjowa obiekt przy konstrukcji.

#!csharp

public class Duck
{
    public string Name { get; set; }
    public string Color { get; set; }
}

var duck = new Duck { Name = "Jacu", Color = "Yellow" };

Console.WriteLine(duck.Name);
Console.WriteLine(duck.Color);

#!markdown

<h3 id="keyword--init-">1.15 Keyword `init`</h3> <small><a href="#toc">Back to top</a></small>

Idiom z inicjowaniem p贸l przy konstrukcji jest bardzo przydatny, na tyle, 偶e istnieje specjalny keyword, kt贸ry reprezentuje setter dostpny jedynie przy konstrukcji.

#!csharp

public class Duck
{
    public string Name { get; init; }
    public string Color { get; init; } = "Yellow";

    public Duck(string name) => 
	      Name = name; // `init` can be called in constructor
}

// `init` can be called during initialization.
var duck = new Duck("Jacu") { Color = "Green" };

Console.WriteLine(duck.Name);
Console.WriteLine(duck.Color);

#!csharp

// This is an error.
duck.Name = "Piotru";

#!markdown

<h3 id="sealed">1.16 Sealed</h3> <small><a href="#toc">Back to top</a></small>
Klasy mo偶emy zamkn na dziedziczenie poprzez keyword `sealed`. Mo偶na te偶 nim zablokowa dalsze przeadowywanie metody wirtualnej.

#!csharp

public sealed class Duck
{
}

// This is an error.
public class BetterDuck : Duck
{
}

#!markdown

Wikszo klas powinna by `sealed`.

#!markdown

<h3 id="klasy-abstrakcyjne">1.17 Klasy abstrakcyjne</h3> <small><a href="#toc">Back to top</a></small>

Klasy abstrakcyjne su偶 do implementacji czci interfejsu i pozostawienia pewnych szczeg贸贸w dla implementujcych klasy dziedziczce. Mog posiada metody bez implementacji. Klasa abstrakcyjna nie mo偶e zosta zainstancjonowana, ale mo偶e mie konstruktor.

#!csharp

public abstract class DuckBase
{
    public int TimesSqueaked { get; private set; } = 0;
    
    public DuckBase() =>
        Console.WriteLine("Duck base created!");

    public void Squeak()
    {
        ProcessSqueak();
        ++TimesSqueaked;
    }
    
    protected abstract void ProcessSqueak();
}

public sealed class Duck : DuckBase
{
    public Duck() : base() =>
        Console.WriteLine("Duck created!");

    protected override void ProcessSqueak() =>
        Console.WriteLine("Squeak!");
}

var duck = new Duck();
duck.Squeak();
Console.WriteLine(duck.TimesSqueaked);

#!markdown

<h3 id="enums">1.18 Enums</h3> <small><a href="#toc">Back to top</a></small>

Enumy w C# s jednym ze sabych punkt贸w jzyka.

#!csharp

public enum Color 
{
    Red,
    Yellow,
    Green,
    Blue,
    Black
}

var color = Color.Red;

#!markdown

Enum jest tak naprawd zmienn typu `int` przebran za enum.

#!csharp

public enum Color
{
   Red = 1,
   Yellow = 2,
   Green = 4,
   Blue = 8,
   Black = 16,
   Purple = 32,
}

var mix = Color.Red | Color.Yellow | Color.Black;
Console.WriteLine((int)mix);

#!markdown

<h3 id="reference-types-vs-value-types">1.19 Reference types vs Value types</h3> <small><a href="#toc">Back to top</a></small>

W C# istnieje te偶 keyword `struct` su偶cy do tworzenia nowych typ贸w. W przeciwiestwie do C++ r贸偶nica pomidzy `class` a `struct` istnieje i jest znaczna. Klasy reprezentuj reference types, structy value types.

- **Reference type** - instancja tego typu zawiera referencj (wska藕nik) na blok pamici zawierajcy dane obiektu; przekazanie takiej instancji np. jako parametr funkcji i zmodyfikowanie w niej czego poskutkuje zmian oryginalnego obiektu

#!csharp

public void SqueakADuck(Duck duck)
{
    duck.Squeak();
}

var duck = new Duck();

SqueakADuck(duck);

Console.WriteLine(duck.TimesSqueaked);

#!markdown

- **Value type** - obiekty tego typu s _zawsze_ kopiowane przez warto; wszystkie typy wbudowane poza `object` i `string` s Value types

#!csharp

public struct DuckData
{
    public string Name { get; }
    public Color Color { get; }
    
    public DuckData(string name, Color color)
    {
        Name = name;
        Color = color;
    }
}


var duckData = new DuckData("Jacu", Color.Yellow);

#!markdown

Odwoanie si do value type _zawsze_,  **zawsze** zwraca kopi. Z tego powodu Value types zawsze powinny by immutable.

#!csharp

public struct MutableStruct
{
    public int Value { get; set; }
}

public void Mutate(MutableStruct x)
{
    Console.WriteLine($"Inside Mutate: {x.Value}");
    x.Value += 1;
    Console.WriteLine($"On Mutate return: {x.Value}");
}

var x = new MutableStruct { Value = 42 };

Console.WriteLine($"Before Mutate call: {x.Value}");
Mutate(x);
Console.WriteLine($"After Mutate call: {x.Value}");

#!markdown

Istnieje przydatny keyword, kt贸rego mo偶emy u偶y, aby to zapewni: `readonly`. Zadeklarowanie structa jako `readonly` daje gwarancj, 偶e bdzie immutable.

#!csharp

public readonly struct MutableStruct
{
    // The setter causes an error.
    public int Value { get; set; }
}

#!csharp

public readonly struct MutableStruct
{
    // Using init is OK.
    public int Value { get; init; }
}

#!markdown

Wszystkie keywordy `int`, `object`, `string` itp. s tak naprawd jedynie aliasami na typy `struct System.Int32`, `class System.Object`, `class System.String`.

Domyln wartoci reference type jest `null`,  domyln wartoci value type s wyzerowane bity. Value types nie mog mie bezparametrowych ctor贸w (maj domylny). Value types nie mog po niczym dziedziczy (ani nie mo偶na dziedziczy po nich), ale mog implementowa interfejsy.

#!markdown

<h3 id="nullability">1.20 Nullability</h3> <small><a href="#toc">Back to top</a></small>

C# od pocztku istnienia dziaa tak jak Java: referencje zawsze mo偶na ustawi na `null`.

#!csharp

Duck duck = null;

#!markdown

Z kolei structy nie mog by `null`.

#!csharp

DuckData data = null; // Does not compile.

#!markdown

Istnieje specjalna skadnia dla value types, kt贸ra pozwala zmieni je w nullable:

#!csharp

void PrintName(DuckData? data)
{
    if (data.HasValue)
    {
        Console.WriteLine(data.Value.Name);
    }
    else 
    {
        Console.WriteLine("null");
    }
}

DuckData? nullData = null;
DuckData? nonNullData = new DuckData("Jacu", Color.Yellow);

PrintName(nullData);
PrintName(nonNullData);

#!markdown

Pod spodem `DuckData?` to tak naprawd `Nullable<DuckData>`, kt贸re zawiera po prostu dodatkow flag `bool` m贸wic, czy warto jest `null`em.

Od .NET-a 5 mamy te偶 nullable reference types. Domylnie linijka

#!csharp

#nullable enable

Duck duck = null;

#!markdown

rzuci warning, 偶e przypisujemy `null` na not-nullable reference type. 呕eby si go pozby, trzeba zadeklarowa zmienn jako nullable:

#!csharp

#nullable enable

Duck? duck = null;

#!markdown

W przeciwiestwie do struct贸w jest to jedynie anotacja dla kompilatora. Powie nam np., 偶e

#!csharp

#nullable enable

void SqueakAPotentiallyNullDuck(Duck? duck)
{
    duck.Squeak();
}

#!markdown

jest niebezpieczne: `duck` jest nullable i nie sprawdzilimy, czy nie jest `null`em. Poprawnym postpowaniem w takim przypadku jest, c贸偶, sprawdzenie tego:

#!csharp

#nullable enable

void SqueakAPotentiallyNullDuck(Duck? duck)
{
    if (duck is not null)
    {
        duck.Squeak();
    }
}

#!markdown

 Mo偶na taki warning te偶 zignorowa bang operatorem:

#!csharp

#nullable enable

void SqueakAPotentiallyNullDuck(Duck? duck)
{
    duck!.Squeak();
}

#!markdown

Niestety w notebookach Nullable Reference Types (tak si nazywa ten ficzer) s wyczone by default i nie da si ich globalnie wczy, dlatego bdziemy robi to rcznie u偶ywajc `#nullable enable`. Swoj drog, da si te偶 NRE wyczy na dany fragment kodu:

#!csharp

#nullable enable


#nullable disable
void SqueakAPotentiallyNullDuck(Duck? duck)
{
    duck.Squeak();
}
#nullable restore

#!markdown

<h3 id="parametry--ref--i--out-">1.21 Parametry `ref` i `out`</h3> <small><a href="#toc">Back to top</a></small>

C# pozwala na mao eleganckie przekazywanie zmiennych przez referencj. Mo偶na wic przekaza referencj na referencj lub referencj na value type.

#!csharp

public class Duck { }

public void Nullify(ref Duck duck)
{
    duck = null;
}

public void Zero(ref int i)
{
    i = 0;
}

public void Set(out int i)
{
    i = 42;
}

var duck = new Duck();
var i = 42;

Nullify(ref duck);
Console.WriteLine(duck == null ? "Null" : "Not null");

Zero(ref i);
Console.WriteLine(i);

int j;
Set(out j);
Console.WriteLine(j);

#!markdown

R贸偶nica midzy `ref` a `out` - `ref` musi by przypisany przed przekazaniem, `out` nie. Metoda musi przypisa co do `out`, do `ref` nie.

#!markdown

<h3 id="r-wno--">1.22 R贸wno</h3> <small><a href="#toc">Back to top</a></small>

Istnieje metoda `static bool Object.ReferenceEquals(object, object)`, kt贸ra sprawdza, czy przekazane obiekty s tym samym.

Istnieje metoda `bool Object.Equals(object)`, kt贸r dziedzicz wszystkie typy. Domylnie por贸wnanie za pomoc `Equals` jest r贸wnowa偶ne `ReferenceEquals` dla reference types, a dla value types por贸wnuje ka偶dy bit. Da si j przeci偶y.

Domylnie por贸wnanie za pomoc operatora `==` jest r贸wnowa偶na `ReferenceEquals` dla reference types i jest niezdefiniowany dla value types. Da si go przeci偶y.
Wszystkie wbudowane value types maj przeci偶one `==` na r贸wnowa偶ne `Equals`. 

**Wyjtkowo `string` r贸wnie偶 przeci偶a `==` i por贸wnuje wartoci!**

Przy przeci偶aniu `Equals` powinno si przeci偶a te偶 `int Object.GetHashCode()`. Poni偶ej idiomatyczna implementacja `Equals`.

#!csharp

public class Duck : IEquatable<Duck>
{
    public string Name { get; }
    public Color Color { get; }

    public Duck(string name, Color color)
    {
        Name = name;
        Color = color;
    }

    public override int GetHashCode() =>
        HashCode.Combine(Name, Color);

    public bool Equals(Duck other) => 
        // Strings can be compared with == and it behaves as expected.
        Name == other.Name && Color == other.Color;

    public override bool Equals(object obj) =>
	      obj is Duck other && other.Equals(obj);
}

var jacu = new Duck("Jacu", Color.Yellow);
var piotru = new Duck("Piotru", Color.Yellow);
var jacu2 = new Duck("Jacu", Color.Yellow);

Console.WriteLine(object.ReferenceEquals(jacu, piotru));
Console.WriteLine(object.ReferenceEquals(jacu, jacu2));
Console.WriteLine(jacu.Equals(piotru));
Console.WriteLine(jacu.Equals(jacu2));

#!markdown

<h3 id="parse-i-tryparse">1.23 Parse i TryParse</h3> <small><a href="#toc">Back to top</a></small>

Do konwersji string贸w na liczby u偶ywa si funkcji `Parse` lub `TryParse`.  Ta pierwsza rzuca wyjtek przy niepowodzeniu, ta druga zwraca `boola` i wypenia `out` parameter jeli si udao.

#!csharp

int i = int.Parse("42");
Console.WriteLine(i);

#!csharp

int j;
bool success = int.TryParse("42", out j);
Console.WriteLine(success);
Console.WriteLine(j);

#!markdown

Mo偶na te偶 ola `out` parameter (nie tylko w `TryParse`, tak og贸lnie) i dosta tylko `boola`.

#!csharp

var success = int.TryParse("42", out _);
Console.WriteLine(success);

#!markdown

`bool TryX(out T t)` jest do czstym patternem w C#.

#!markdown

<h3 id="generics">1.24 Generics</h3> <small><a href="#toc">Back to top</a></small>

Generyczne mog by zar贸wno typy jak i metody. Przykadem generycznej klasy jest np. `List<T>`, kt贸ry mo偶e przechowywa dowolne obiekty. W przeciwiestwie do pewnego jzyka na J, informacja o typie zostaje zachowana at runtime.

#!csharp

public class Duck { }
public class BetterDuck : Duck { }

public static void PrintDuckType<TDuck>(TDuck duck)
{
    var genericArgumentName = typeof(TDuck).Name;
    var actualTypeName = duck.GetType().Name;
    Console.WriteLine("I was passed a " + actualTypeName + " as a " + genericArgumentName + ".");
}

var duck = new Duck();
var betterDuck = new BetterDuck();
Duck betterDuckDisguisedAsADuck = new BetterDuck();

PrintDuckType(duck);
PrintDuckType(betterDuck);
PrintDuckType(betterDuckDisguisedAsADuck);

#!csharp

public class A { }
public class B<T> : A { }
public class C : B<int> { }
public class D<T, U> : B<T>

#!markdown

Generyki z C# s stricte lepsze ni偶 te z Javy, ale nie s Turing complete jak te z C++. Prawdopodobnie najwikszym ograniczeniem jest brak variadic generics.

#!markdown

<h3 id="generic-constraints">1.25 Generic constraints</h3> <small><a href="#toc">Back to top</a></small>

Umo偶liwianie przekazania dowolnego typu do generycznej klasy lub metody z reguy jest mao przydatne. Mo偶na jednak nao偶y ograniczenia na typ generyczny - kaza mu implementowa jakie interfejsy lub dziedziczy po konkretnej klasie.

#!csharp

public interface IDuck
{
    void Squeak();
}

public interface ISqueakTracker
{
   int TimesSqueaked { get; }
}

public class Duck : IDuck, ISqueakTracker
{
    public int TimesSqueaked { get; protected set; } = 0;
    
    public virtual void Squeak()
    {
        Console.WriteLine("Squeak!");
        ++TimesSqueaked;
    }
}

public static void SqueakIfNew<TDuck>(TDuck duck) 
    where TDuck : IDuck, ISqueakTracker
{
    if(duck.TimesSqueaked > 0)  // ISqueakTracker
    {
        Console.WriteLine("No squeaking for you!");
        return;
    }
    
    duck.Squeak();  // IDuck
}

var duck = new Duck();
SqueakIfNew(duck);
SqueakIfNew(duck);

#!markdown

Istniej te偶 inne, specjalne ograniczenia:
- `where T : class` - `T` musi by typem referencyjnym;
- `where T : struct` - `T` musi by value typem;
- `where T : new()` - `T` musi mie dostpny, bezparametrowy ctor

Jeli nadajemy ograniczenia na dwa typy to piszemy drugie `where`.

#!csharp

public class A<T, U> where T : class, new()
                     where U : T
{
}

#!markdown

C# nie ma dziwnych ogranicze na u偶ywanie generyk贸w jak Java, parametrem generycznym mo偶e by dowolny typ. Nie jest jednak tak szalony jak C++, wic z reguy da si zrozumie o co chodzi.

#!markdown

<h3 id="kolekcje">1.26 Kolekcje</h3> <small><a href="#toc">Back to top</a></small>

.NET udostpnia generyczne kolekcje i interfejsy w `System.Collections.Generic`.

**Intefejsy**:
- `IEnumerable<T>` - cokolwiek, po czym mo偶na si przeiterowa, korzysta z tego `foreach`;
- `ICollection<T>` - dziedziczy po `IEnumerable<T>`, udostpnia operacje `Add(T)`, `Remove(T)`, `Contains(T)` i property `Count`;
- `IList<T>` - dziedziczy po `ICollection<T>`, udostpnia indeksator `[]`;
- `IDictionary<TKey, TValue>` - dziedziczy po `ICollection<KeyValuePair<TKey, TValue>>`,  udostpnia dodawanie par klucz-warto i odwoywanie si po kluczu przez indeksator.

**Klasy**:
- `List<T>` - implementuje `IList<T>`, rozszerzalna tablica tak jak `std::vector<T>` z C++;
- `Dictionary<TKey, TValue>` - implementuje `IDictionary<TKey, TValue>`, hashmapa;
- `Stack<T>` - stos;
- `Queue<T>` - kolejka FIFO;
- `LinkedList<T>` - lista dwukierunkowa;
- `HashSet<T>` - zgaduj-zgadula;
- `SortedDictionary<TKey, TValue`, `SortedSet<T>` - odpowiedniki `Dictionary` i `HashSet` na drzewach BST;
- `SortedList<TKey, TValue>` - posortowana lista (taka ze wstawianiem w $\mathcal{O}(n)$)
- `Lookup<TKey, TValue>` - sownik, ale do ka偶dego klucza mo偶e by wiele wartoci

Lista jest najpowszechniejsz z kolekcji. Do iterowania si po kolekcjach w $90\%$ przypadk贸w u偶ywamy `foreacha`. Do inicjalizowania kolekcji wygodnie u偶y...  no c贸偶, inicjalizatora kolekcji.

#!csharp

var list = new List<int> { 2, 1, 3, 7 };

foreach(var num in list)
{
    Console.Write(num);
}
Console.WriteLine();

#!markdown

<h3 id="stringi">1.27 Stringi</h3> <small><a href="#toc">Back to top</a></small>

Wspomnielimy ju偶, 偶e por贸wnywanie zmiennych typu `string` za pomoc `==` jest intuicyjne. Nale偶y pamita tak偶e o bardzo wa偶nej rzeczy - stringi s immutable. To znaczy, 偶e wywoanie:

#!csharp

var str = "Hello";
str += " World!";

#!markdown

spowoduje stworzenie zupenie nowego stringa `"Hello World!"` i przypisanie go do zmiennej `str`. Wic gdyby chcie np. stworzy z cigu zer i jedynek napis skadajcy si z liter `a` i `b` w taki spos贸b:

#!csharp

string ToABString(int[] sequence)
{
    var result = "";
    
    foreach(var element in sequence)
    {
        result += (element == 0 ? "a" : "b");
    }
    
    return result;
}

var abString = ToABString(new [] {0, 1, 0, 0, 1, 1});
Console.WriteLine(abString);

#!markdown

to zo偶ono czasowa i pamiciowa wyniesie $\mathcal{O}($`sequence.Length`$^2)$. Do takich kosztownych operacji su偶y klasa `StringBuilder`.

#!csharp

string ToABString(int[] sequence)
{
    var stringBuilder = new StringBuilder();
    
    foreach(var element in sequence)
    {
        stringBuilder.Append(element == 0 ? 'a' : 'b');
    }
    
    return stringBuilder.ToString();
}

var abString = ToABString(new [] {0, 1, 0, 0, 1, 1});
Console.WriteLine(abString);

#!markdown

Stringi te偶 wystpuj w r贸偶nych smakach. Mamy zwyke, interpolowane i verbatim.
- **Interpolated string** - pozwala na wplecenie wartoci zmiennych do literau

#!csharp

public class Duck
{
    public string Name { get; } 
    public int TimesSqueaked { get; private set; } = 0;

    public Duck(string name)
    {
        Name = name;
    }

    public void Squeak()
    {
        ++TimesSqueaked;
        Console.WriteLine($"Duck {Name}: Squeak! [Squeak #{TimesSqueaked}]");
    }
}

var duck = new Duck("Jacu");
duck.Squeak();
duck.Squeak();

#!markdown

Jest to "mniej wicej r贸wnowa偶ne" napisaniu

#!csharp

Console.WriteLine("Duck " + Name + ": Squeak! [Squeak #" + TimesSqueaked + "]");

#!markdown

A dla cisoci jest dokadnie r贸wnowa偶ne

#!csharp

string.Format("Duck {0}: Squeak! [Squeak #{1}]", Name, TimesSqueaked);

#!markdown

- **Verbatim string** - pozwala na dosowne interpretowanie stringa

#!csharp

var str = "\n";
var verbatimStr = @"\n";

Console.WriteLine(str);
Console.WriteLine(verbatimStr);

#!markdown

Mo偶na te typy czy ze sob

#!csharp

var duck = new Duck("Jacu");
var mix = $@"{duck.Name}\n";
Console.WriteLine(mix);

#!markdown

<h3 id="statyczne-klasy">1.28 Statyczne klasy</h3> <small><a href="#toc">Back to top</a></small>

Czasami metody albo stae nie nale偶 do 偶adnej konkretnej instancji, ale s og贸ln wasnoci klasy. Deklarujemy je wtedy jako `static`. Czsto jednak zdarza si, 偶e mamy wiele pomocniczych metod, kt贸re nijak nie s zwizane z konkretnym obiektem (np. klasa `Math`). Wtedy tak klas mo偶na zadeklarowa jako statyczn. Nie mo偶e mie ona ctora  i nie da si stworzy jej instancji. Wszystkie jej skadowe te偶 musz by statyczne.

#!csharp

public static class Math
{
    public const double E = 2.7182818284590452354;
    public const double Pi = 3.14159265358979323846;

    public static double Max(double val1, double val2) => (val1 >= val2) ? val1 : val2;
}

Console.WriteLine(Math.Max(Math.E, Math.Pi));

#!markdown

<h3 id="extension-methods">1.29 Extension methods</h3> <small><a href="#toc">Back to top</a></small>

Bardzo ciekawym mechanizmem jzyka s extension methods. Jest to co prawda jedynie lukier syntaktyczny, ale pozwala nam wywoywa metody na obiektach danego typu jakby byy ich memberami.

#!csharp

public static class DuckExtensions
{
    public static void SqueakNTimes(this Duck duck, int n)
    {
        for(var i = 0; i < n; ++i)
        {
            duck.Squeak();
        }
    }
}

var duck = new Duck("Jacu");

duck.SqueakNTimes(3);

#!markdown

Nie dziaa w notebookach niestety, bo nie mo偶e by to zagnie偶d偶ona klasa :/

#!markdown

Nie mo偶na w ten spos贸b obej access specifier贸w - widzimy tylko publiczne rzeczy (ewentualnie `internal`). Jest to "tylko" lukier syntaktyczny, ale jak偶e przydatny!

#!markdown

<h3 id="operatory">1.30 Operatory</h3> <small><a href="#toc">Back to top</a></small>

W C# mamy standardowe operatory jak w C lub C++. Przydatn informacj jest to, 偶e operatory `||` oraz `&&` s leniwe (defacto s zaimplementowane za pomoc `|` i `&`). W przypadku `bool?` zachowanie tych operator贸w jest takie jak w SQL-u (stety/niestety).

C# ma te偶 tzw. null-coalescing operator `??

#!csharp

a ?? b;

#!markdown

jest r贸wnowa偶ne

#!csharp

a != null ? a : b;

#!csharp

int? a = 37;
int? b = 42;
int? c = null;

Console.WriteLine(a ?? b);
Console.WriteLine(c ?? b);

#!markdown

Oraz operator `?.`

#!csharp

a?.Property;

#!markdown

jest r贸wnowa偶ne

#!csharp

a != null ? a.Property : null;

#!csharp

#nullable enable

Duck? duck = new Duck("Jacu");
Duck? nullDuck = null;

string StringCoalesce(string? s) => s ?? "null";

Console.WriteLine(StringCoalesce(duck?.Name));
Console.WriteLine(StringCoalesce(nullDuck?.Name));

#!csharp

#nullable enable

Console.WriteLine(StringCoalesce(nullDuck.Name));

#!markdown

<h3 id="rzutowanie">1.31 Rzutowanie</h3> <small><a href="#toc">Back to top</a></small>
- Casty, przy kt贸rych nie ma ryzyka utraty informacji s implicit.

#!csharp

int a = 42;
long b = a;  // Implicit cast.

#!markdown

- Cast mo偶e by explicit at compile time, wtedy zawsze si udaje albo nie kompiluje.

#!csharp

public class Duck 
{ 
    public void Squeak() => Console.WriteLine("Squeak!");
}
public class BetterDuck : Duck 
{ 
    public void BetterSqueak() => Console.WriteLine("Better squeak!");
}

var betterDuck = new BetterDuck();
var duck = (Duck)betterDuck;

#!markdown

- Cast mo偶e by explicit at runtime, wtedy mo偶e rzuci `InvalidCastException`.

#!csharp

var duck = new Duck();
var betterDuck = (BetterDuck)duck; // Throws at runtime.

#!csharp

Duck duck = new BetterDuck();
var betterDuck = (BetterDuck)duck; // Succeeds at runtime.

#!markdown

- Cast mo偶e by safe at runtime z u偶yciem `as` lub `is`.

#!csharp

var duck = new Duck();
var betterDuck = duck as BetterDuck; // Fails, betterDuck == null.

if (betterDuck is null)
{
    Console.WriteLine("Failed");
}
else
{
    Console.WriteLine("Succeeded");
}

#!csharp

Duck duck = new BetterDuck();
var betterDuck = duck as BetterDuck; // Succeeds, duck == betterDuck.

if (betterDuck is null)
{
    Console.WriteLine("Failed");
}
else
{
    Console.WriteLine("Succeeded");
}

#!csharp

Duck duck = new BetterDuck();
if(duck is BetterDuck)
{
    Console.WriteLine("Success!");
}

#!csharp

Duck duck = new BetterDuck();
BetterDuck betterDuck = duck as BetterDuck;
if(betterDuck is not null)
{
    betterDuck.Squeak();
}

#!markdown

To samo, tylko zwi藕lej:

#!csharp

Duck duck = new BetterDuck();
if(duck is BetterDuck betterDuck)
{
    betterDuck.BetterSqueak();
}

#!markdown

<h3 id="boxing">1.32 Boxing</h3> <small><a href="#toc">Back to top</a></small>
Przy takim przypisaniu:

#!csharp

int i = 42;
object obj = i;

#!markdown

nastpuje boxing, czyli opakowanie value type w reference type. Operacja odwrotna to unboxing:

#!csharp

int j = (int)obj;

#!markdown

Boxing z偶era czas (dokadniej to a lot of boxing = a lot of garbage collection, which is expensive), wic nale偶y go unika, jeli to mo偶liwe.

#!markdown

<h3 id="przeci--anie-operator-w">1.33 Przeci偶anie operator贸w</h3> <small><a href="#toc">Back to top</a></small>

Tak, mo偶na! Nie mo偶na tylko przypisania i `||`/`&&` (ale mo偶na `|`/`&`). Mo偶na nawet przeci偶y `==`, cho jest to niezalecane. Por贸wnania musz by przeci偶ane parami.

#!csharp

public class Duck
{
    public string Name { get; }

    public Duck(string name)
    {
        Name = name;
    }

    public static bool operator ==(Duck duck1, Duck duck2) => duck1?.Name == duck2?.Name;

    public static bool operator !=(Duck duck1, Duck duck2) => !(duck1 == duck2);
}
var duck = new Duck("Jacu");
var otherDuck = new Duck("Jacu");

Console.WriteLine(object.ReferenceEquals(duck, otherDuck));
Console.WriteLine(duck == otherDuck);

#!markdown

Przeci偶anie `==` bez `Equals` jest do gupie, std nawet kompilator daje nam warning z tego powodu.

#!markdown

<h3 id="indekser">1.34 Indekser</h3> <small><a href="#toc">Back to top</a></small>

Nasz typ mo偶e definiowa sw贸j indekser, tj. zachowanie dla operatora `[]`.

#!csharp

public class MyTableWrapper<T>
{
    private readonly T[] _tab;

    public MyTableWrapper(int length)
    {
        _tab = new T[length];
    }
    
    public T this[int i]
    {
        get => _tab[i];
        set => _tab[i] = value;
    }
}

var wrapper = new MyTableWrapper<int>(10);

wrapper[3] = 42;
wrapper[6] = 37;

for (var i = 0; i < 10; i += 1)
{
    Console.WriteLine(wrapper[i]);
}

#!markdown

<h3 id="tuples--valuetuple-">1.35 Tuples (ValueTuple)</h3> <small><a href="#toc">Back to top</a></small>

Wspomnielimy wczeniej o Tuple'ach, jednak w C# 7 u偶ywa si ValueTuples. Pozwalaj one na nazwanie p贸l:

#!csharp

var myPoint = (x: 4, y: 2);
Console.WriteLine(myPoint.x);
Console.WriteLine(myPoint.y);

#!markdown

Takie tuple mo偶na te偶 dekonstruowa w miejscu:

#!csharp

var (x, y) = myPoint;
Console.WriteLine(x);
Console.WriteLine(y);

#!markdown

ValueTuple to struct.

#!markdown

<h3 id="wyj-tki">1.36 Wyjtki</h3> <small><a href="#toc">Back to top</a></small>

Wyjtki rzuca si `throw`, ka偶dy wyjtek musi dziedziczy po `System.Exception`. Wyjtki apie si konstrukcj `try`/`catch` i mo偶na je zrethrowowa. 

#!csharp

try
{
    /* ... */
}
catch(InvalidOperationException exception)
{
    Console.WriteLine(exception.Message);
    throw;
}

#!markdown

Jeli nie obchodzi nas jaki wyjtek apiemy (rzadko), piszemy:

#!csharp

try
{
    /* ... */
}
catch
{
   /* ... */
}

#!markdown

jeli nie potrzebujemy obiektu wyjtku, mo偶emy napisa

#!csharp

try
{
    /* ... */
}
catch(InvalidOperationException) // Without declaring a variable.
{
    /* ... */
}

#!markdown

C# ma te偶 konstrukcj `finally`. Kod w bloku `finally` wywouje si zawsze, nawet w przypadku wyjtku. Mo偶e wystpi bez `catcha`.

#!markdown

<h3 id="garbage-collector">1.37 Garbage collector</h3> <small><a href="#toc">Back to top</a></small>

Nie bdziemy wchodzi w szczeg贸y GC. Najwa偶niejsze informacje to:

- Wszystkie obiekty na stercie, do kt贸rych nie istnieje cie偶ka w grafie obiekt贸w s niekatywne.
- GC od czasu do czasu przechodzi si po stercie i usuwa nieaktywne obiekty. Cay proces jest skomplikowany .
- Value types s **zazwyczaj** alokowane na stosie. Wyjtki to midzy innymi pola klas i rzeczy zapane przez delegaty.

#!markdown

<h3 id="dispose">1.38 Dispose</h3> <small><a href="#toc">Back to top</a></small>

Jeli klasa trzyma jaki managed resource, kt贸ry jest "ci偶ki", np. file handle, poczenie z baz danych itp., powinien implementowa `IDisposable`. Interfejs ten zawiera jedn metod `void Dispose()`, kt贸ra ma zwolni zasoby. 

wita zasada C# na temat `IDisposable` to:

**Na ka偶dym obiekcie implementujcym `IDisposable` nale偶y wywoa metod `Dispose` DOKADNIE RAZ.**

Jest jeszcze do naturalna zasada, i偶 obiekt贸w, kt贸re ju偶 zdisposowalimy nie mo偶na u偶ywa do niczego. Ka偶dy call na obiekcie, kt贸ry ju偶 by disposed ma wite prawo strzeli nam w twarz wyjtkiem (jest nawet specjalny wyjtek na takie okolicznoci, `ObjectDisposedException`).

Wspomnielimy wczeniej o bloku `finally`. Jest jednak o wiele przyjemniejszy syntax sugar w postaci dyrektywy `using`.

#!csharp

public class Repository : IDisposable
{
    public void DoStuff() => Console.WriteLine("Doing stuff...");
    
    public void Dispose() => Console.WriteLine("Disposing...");
}

public static void DoStuffWithRepo()
{
    using(var repo = new Repository())
    {
        repo.DoStuff();
    }
}

DoStuffWithRepo();

#!markdown

albo kr贸cej:

#!csharp

public static void DoStuffWithRepo()
{
    using var repo = new Repository();
    repo.DoStuff();
}

DoStuffWithRepo();

#!markdown

jest r贸wnowa偶ne

#!csharp

public static void DoStuffWithRepo()
{
    var repo = new Repository();
    try 
    {
        repo.DoStuff();
    }
    finally
    {
        repo?.Dispose();
    }
}

DoStuffWithRepo();

#!markdown

a wic posprztamy nawet przy wyjtku:

#!csharp

public static void DoStuffWithRepo()
{
    using var repo = new Repository();

    Console.WriteLine("Throwing!");
    throw new InvalidOperationException("Tee hee!");

    repo.DoStuff();
}

DoStuffWithRepo();

#!markdown

<h3 id="atrybuty">1.39 Atrybuty</h3> <small><a href="#toc">Back to top</a></small>

Atrybuty zawieraj metadane. Same z siebie nie za wiele robi, ale mo偶na si do nich dosta przez refleksj i wyuska dane (bdziemy ich bardzo u偶ywa przy ASP i EF). Ka偶dy atrybut ma nazw koczc si na `Attribute` i dziedziczy po `Attribute`.
Przykadowo atrybut `ObsoleteAttribute`, u偶ywany przez kompilator do nakrzyczenia na u偶ytkownika danej metody:

#!csharp

public class MyClass
{
    [Obsolete]
    public void MyMethod()
    {
        /* ... */
    }
}

#!markdown

Jeli konstruktor atrybutu przyjmuje jakie argumenty, to podajemy je w tagu.

#!csharp

public class MyClass
{
    [Obsolete("This method is deprecated because of reasons, don't use it")]
    public void MyMethod()
    {
        /* ... */
    }
}

#!markdown

<h3 id="-nameof-">1.40 `nameof`</h3> <small><a href="#toc">Back to top</a></small>

`nameof` zostaje statycznie zamienione na nazw zmiennej/pola/metody etc.

#!csharp

public class Duck
{
    public void Squeak() => Console.WriteLine("Squeak!");
}

var duck = new Duck();
Console.WriteLine($"{nameof(Duck)}!");
Console.WriteLine($"{nameof(duck)}!");
Console.WriteLine($"{nameof(duck.Squeak)}!");

#!markdown

<h3 id="anonimowe-obiekty">1.41 Anonimowe obiekty</h3> <small><a href="#toc">Back to top</a></small>

Czasami potrzebujemy stworzy sobie jaki prosty obiekt po prostu grupujcy jakie wartoci razem. Tworzenie za ka偶dym razem specjalnej klasy i woanie jej konstruktora byoby 偶mudne, dlatego mo偶emy sobie stworzy typ anonimowy:

#!csharp

var someData = new
{
    Name = "Jacu",
    Color = Color.Green
};

Console.WriteLine(someData);

#!markdown

Nazwy tego typu nie da si nigdzie u偶y, wic z reguy jego u偶ycie jest ograniczone do lokalnych transformacji. By necessity zmienne z takimi obiektami trzeba deklarowa z `var`. Bardzo si przydadz przy LINQ, o kt贸rym ju偶 za chwil.

#!markdown

<h3 id="delegates">1.42 Delegates</h3> <small><a href="#toc">Back to top</a></small>

Delegaty to type-safe function references. Najpierw trzeba zadeklarowa sam typ:

#!csharp

public delegate int BinaryOperator(int lhs, int rhs);

#!markdown

Mo偶e on by skadow jakiej klasy albo by luzem w namespace'ie. Nastpnie mo偶emy przypisa do zmiennej tego typu jak metod i j wywoa.

#!csharp

public static int Plus(int a, int b) => a + b;

BinaryOperator binaryOperator = Plus;

Console.WriteLine(binaryOperator(17, 25));

#!markdown

.NET udostpnia dwa fundamentalne, generyczne typy delagat贸w:
- `Action<T1, T2, ..., TN>` - metoda niezwracajca 偶adnej wartoci, przyjmujca N argument贸w typ贸w kolejno `T1`, `T2`, ..., `TN`;
- `Func<T1, T2, ..., TN, TResult>` - metoda zwracajca `TResult` i przyjmujca N argument贸w  typ贸w kolejno `T1`, `T2`, ..., `TN`;

Jeli przypiszemy do delegata instance method, to delegat zapie t konkretn instancj i `this` w ciele przypisanej metody bdzie si do niej odwoywa.

#!markdown

<h3 id="lambdy">1.43 Lambdy</h3> <small><a href="#toc">Back to top</a></small>

Bardzo czsto do delegat贸w przypisujemy kr贸tkie wyra偶enia i nie ma sensu tworzy dla nich dedykowanych metod. I tu wchodz lambdy, cae na biao.

#!csharp

BinaryOperator binaryOperator = (int a, int b) => a + b;

#!markdown

Typy mog zosta wydedukowane przez kompilator.

#!csharp

BinaryOperator binaryOperator = (a, b) => a + b;

#!markdown

Mog mie penoprawne ciaa:

#!csharp

BinaryOperator binaryOperator = (a, b) =>
{
    Console.WriteLine("Lambdas are awesome!");
    return a + b;
};
Console.WriteLine(binaryOperator(17, 25));

#!markdown

Argumenty lambd mog by `ref` i `out`. 
Lambdy mog nie mie argument贸w

#!csharp

Func<int> f = () => 42;

#!markdown

mog  nic nie zwraca

#!csharp

Action<int> f = x => Console.WriteLine(x);

#!markdown

mog nic nie przyjmowa i nic nie zwraca

#!csharp

Action f = () => Console.WriteLine(42);

#!markdown

No i lambdy s kompatybilne z dowolnym delegatem o odpowiedniej sygnaturze.

#!csharp

BinaryOperator bin = (a, b) => a + b;
Func<int, int, int> fun = (a, b) => a + b;

#!markdown

<h3 id="lokalne-metody">1.44 Lokalne metody</h3> <small><a href="#toc">Back to top</a></small>

Czasami chcemy mie metod, kt贸r wywoamy kilkukrotnie w czasie wywoywania naszej logiki. Nie chcemy powtarza kodu, ale nie chcemy te偶 tworzy pomocniczej metody u偶ywanej tylko w jednym miejscu i nie majcej wartoci poza tym konkretnym miejscem. Mo偶na wtedy u偶y lokalnej metody:

#!csharp

public static int CalculateStuff(params (int, int)[] vals)
{
    var sum = 0;

    int Plus(int a, int b) => a + b;
    int Minus(int a, int b) => a - b;

    foreach(var (a, b) in vals)
    {
        sum += Plus(a, b) + Minus(a, b);
    }
    
    return sum / vals.Length;
}

Console.WriteLine(CalculateStuff((17, 25), (11, 33), (35, 21)));

#!markdown

<h3 id="-linq">1.45  LINQ</h3> <small><a href="#toc">Back to top</a></small>

Najlepsz cz C# zostawilimy sobie na koniec. Language Integrated Query - LINQ (czyt. link) - to jzyk zapyta do przetwarzania potokowego kolekcji w C#. Jest to zbi贸r extension methods zdefiniowanych na `IEnumerable` (LINQ to Objects), plikach XML (LINQ to XML) oraz bazach pod Entity Frameworkiem (LINQ to Entities). 

Zakadajc 藕r贸do postaci `IEnumerable<TSource>`, podstawowe operacje to:

#!markdown

<h3 id="-select----projekcja">1.46 `Select` - projekcja</h3> <small><a href="#toc">Back to top</a></small>
`IEnumerable<U> Select(Func<TSource, U>)` pozwala na transformacj danych. Funkcja jest wywoywana dla ka偶dego elementu i zwracany jest enumerable wynik贸w.

#!csharp

public class Duck
{
    public string Name { get; }

    public Color Color { get; init ;} = Color.Yellow;

    public Duck(string name) => Name = name;
}

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth") { Color = Color.Purple }
};

foreach(var name in ducks.Select(d => d.Name))
{
    Console.WriteLine(name);
}

#!markdown

<h3 id="-where----selekcja-filtrowanie">1.47 `Where` - selekcja/filtrowanie</h3> <small><a href="#toc">Back to top</a></small>

`IEnumerable<TSource> Where(Func<T, bool>)` zwraca elementy speniajce dany predykat.

#!csharp

var values = new[] { 7, 42, 21, 1, 8 };

foreach(var val in values.Where(v => v >= 8))
{
    Console.WriteLine(val);
}

#!markdown

<h3 id="-orderby----thenby----sortowanie">1.48 `OrderBy`, `ThenBy` - sortowanie</h3> <small><a href="#toc">Back to top</a></small>

`IOrderedEnumerable<TSource> OrderBy(Func<TSource, TKey>)` - sortowanie po kluczu; na wynikowym `IOrderedEnumerable` mo偶na zastosowa `ThenBy(Func<TSource, TKey>`, 偶eby posortowa po drugiej (trzeciej, czwartej...) wartoci.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth"),
    new Duck("Psuchawrl")
};

foreach(var duck in ducks.OrderBy(d => d.Name[0]).ThenBy(d => d.Name.Length))
{
    Console.WriteLine(duck.Name);
}

#!markdown

Wariantem s `OrderByDescending` oraz `ThenByDescending`.

#!markdown

<h3 id="-query-syntax">1.49  Query syntax</h3> <small><a href="#toc">Back to top</a></small>

LINQ mo偶na te偶 stosowa z pseudo-SQLow skadni. Przykadowo:

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth") { Color = Color.Purple }
};

var result = ducks
  .Where(d => d.Name.Length >= 7)
  .OrderByDescending(d => d.Name.Length)
  .Select(d => new { d.Name.Length, d.Color });

foreach (var val in result)
{
    Console.WriteLine(val);
}

#!markdown

to to samo co

#!csharp

var result = from d in ducks
             where d.Name.Length >= 7
             orderby d.Name.Length descending
             select new { d.Name.Length, d.Color };

foreach (var val in result)
{
    Console.WriteLine(val);
}

#!markdown

W przypadku banalnych query, jak `list.Where(sth)`, lepiej u偶y method syntax. Im bardziej skomplikowane query, tym wiksza szansa 偶e query syntax bdzie czytelniejszy. Pozwala on te偶 na wprowadzanie tzw. transparent identifiers

#!csharp

var result = from d in ducks
             let length = d.Name.Length
             where length >= 7
             orderby length  descending
             select new { Length = length, d.Color };

foreach (var val in result)
{
    Console.WriteLine(val);
}

#!markdown

<h3 id="-selectmany----sp-aszczenie">1.50 `SelectMany` - spaszczenie</h3> <small><a href="#toc">Back to top</a></small>

`IEnumerable<TResult> SelectMany(Func<TSource, IEnumerable<TResult>)` wyuskuje enumerable wynik贸w z ka偶dego elementu i czy (spaszcza) je w jeden.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru")
};

foreach(var letter in ducks.SelectMany(d => d.Name.ToCharArray()))
{
    Console.WriteLine(letter);
}

#!markdown

W query syntax:

#!csharp

var result = from d in ducks
             from l in duck.Name
             select l;

foreach (var letter in result)
{
    Console.WriteLine(letter);
}

#!markdown

<h3 id="-groupby----grupowanie">1.51 `GroupBy` - grupowanie</h3> <small><a href="#toc">Back to top</a></small>

`IEnumerable<IGrouping<TKey, TSource>> GroupBy(Func<TSource, TKey>)`  grupuje po kluczu; ma wiele przeadowa, mo偶e automatycznie robi projekcj wynikowych grupowa i stosowa customowe komparatory.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu") { Color = Color.Yellow },
    new Duck("Piotru") { Color = Color.Red },
    new Duck("Jacu") { Color = Color.Green }
};

foreach(var grouping in ducks.GroupBy(d => d.Name))
{
    Console.WriteLine($"Ducks with name {grouping.Key}:");
    foreach(var duck in grouping)
    {
        Console.WriteLine($"{duck.Name}, {duck.Color} color");
    }
}

#!markdown

W query syntax:

#!csharp

var result = from d in ducks
             group d by d.Name into g
             select g;

foreach(var grouping in result)
{
    Console.WriteLine($"Ducks with name {grouping.Key}:");
    foreach(var duck in grouping)
    {
        Console.WriteLine($"{duck.Name}, {duck.Color} color");
    }
}

#!markdown

<h3 id="-join-">1.52 `Join`</h3> <small><a href="#toc">Back to top</a></small>

`Join(IEnumerable<TInner>, Func<TSource,TKey>, Func<TInner,TKey>, Func<TSource,TInner,TResult>)` zcza dwa enumerable po kluczach i produkuje rezultat dla ka偶dych dw贸ch zmatchowanych element贸w.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu") { Color = Color.Yellow },
    new Duck("Jacu") { Color = Color.Green },
    new Duck("Piotru") { Color = Color.Yellow }
};
var joined = ducks.Join(
    ducks,
    d => d.Name,
    d => d.Name,
    (d1, d2) => (d1.Name, d1.Color, d2.Color));
    
foreach(var (name, colorA, colorB) in joined)
{
    Console.WriteLine($"{name}: {colorA} - {colorB}");
}

#!markdown

W query syntax:

#!csharp

var result = from d1 in ducks
             join d2 in ducks on d1.Name equals d2.Name
             select (d1.Name, d1.Color, d2.Color);

foreach(var (name, colorA, colorB) in joined)
{
    Console.WriteLine($"{name}: {colorA} - {colorB}");
}

#!markdown

<h3 id="inne">1.53 Inne</h3> <small><a href="#toc">Back to top</a></small>

- `Distinct`, mo偶na poda wasny komparator;
- `Skip(int)` - wyrzuca n element贸w z pocztku;
- `SkipLast(int)` - wyrzuca, ale z koca;
- `SkipWhile(Func<TSource, int, bool>)` - wyrzuca dop贸ki predykat jest speniony;
- `Take` - tak jak skip, tylko wybiera elementy zamiast wyrzuca
- `Union`, `Intersect`, `Except` - suma, przecicie, r贸偶nica dw贸ch enumerabli
- `Zip` - splot, taki `Select` na dw贸ch enumerablach  jednoczenie

#!markdown

<h3 id="deferred-execution">1.54 Deferred execution</h3> <small><a href="#toc">Back to top</a></small>

Wszystkie powy偶sze metody tak naprawd si nie wykonuj. LINQ buduje sobie plan wykonania zbudowanego query i wykona go dopiero przy enumeracji, to znaczy po wrzuceniu do `foreacha` albo wykonaniu jednej z operacji, kt贸re ju偶 musz zosta wykonane natychmiastowo (agregacje i budowanie kolekcji).
Warto o tym pamita, po pierwsze dziki temu mo偶na sobie zo偶y zapytanie bardzo szybko z gotowych klock贸w i odpali je asynchronicznie. Po drugie nale偶y bardzo unika tzw. multiple enumerations, przykadowo taki kod:

#!csharp

var ducks = new List<Duck>
{
    /* ... */
};



var names = ducks.Select(d => d.Name); // Deffered, no projection happens here.

foreach(var name in ducks) // Enumeration, the query fires.
{
    Console.WriteLine(name);
}

foreach(var name in ducks) // Another enumeration, another execution.
{
    /* ... */
}

#!markdown

wywouje selekcj dwa razy. Wystarczy sobie wyobrazi, 偶e koszt wywoania tamtej metody jest bardzo du偶y, albo np. operujemy na tabeli w bazie danych i robimy dwa zapytania z tym samym wynikiem zamiast jednego.

#!csharp

var numbers = new [] { 4, 8, 16 };

int ProjectionWithSideeffects(int number)
{
    Console.WriteLine($"Projecting {number}");
    return number * 3;
}

var projection = numbers.Select(n => ProjectionWithSideeffects(n));

Console.WriteLine($"{nameof(projection)} created.");

Console.WriteLine();
Console.WriteLine("Enumerating once.");
foreach (var n in projection)
{
    Console.WriteLine($"Received {n}");
}

Console.WriteLine();
Console.WriteLine("Enumerating again.");

foreach (var n in projection)
{
    Console.WriteLine($"Received {n}");
}

#!markdown

Wszystkie kolejne operacje LINQ wymienione w tej prezentacji powoduj immediate execution.

#!markdown

<h3 id="-tolist----execute-">1.55 `ToList` - execute!</h3> <small><a href="#toc">Back to top</a></small>

Klasyka gatunku, jedna z najczciej u偶ywanych operacji. Kiedy chcemy wykona swoje query i zapisa wynik w `List<TResult>` wywoujemy `ToList()`. Mo偶na tym te偶 przerobi dowolny `IEnumerable` na list, np. `Array` czy `Dictionary`.

Koledzy `ToList` to:
- `ToArray`
- `ToDictionary`
- `ToHashSet`
- `ToLookup`

#!markdown

<h3 id="agregacje">1.56 Agregacje</h3> <small><a href="#toc">Back to top</a></small>

- `int Max(Func<TSource, int>)`,
- `int Min(Func<TSource, int>)`,
- `int Sum(Func<TSource, int>)`,
- `int Average(Func<TSource, int>)`
- `TResult Aggregate(TResult, Func<TResult, TSource, TRessult>)` 

Agreguj enumerable i zwracaj odpowiednio maksimum, minimum, sum, redni i dowoln customow agregacj.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth"),
    new Duck("Psuchawrl")
};

Console.WriteLine(ducks.Aggregate(0, (a, d) => (a + d.Name.Length) % 2));

#!csharp

var numbers = new [] { 4, 8, 16 };

int ProjectionWithSideeffects(int number)
{
    Console.WriteLine($"Projecting {number}");
    return number * 3;
}

var projection = numbers.Select(n => ProjectionWithSideeffects(n));

Console.WriteLine($"{nameof(projection)} created.");

var list = projection.ToList(); // Execution happens here.

Console.WriteLine($"{nameof(list)} created.");

Console.WriteLine();
Console.WriteLine("Enumerating once.");
foreach (var n in list)
{
    Console.WriteLine($"Received {n}");
}

Console.WriteLine();
Console.WriteLine("Enumerating again.");

foreach (var n in list)
{
    Console.WriteLine($"Received {n}");
}

#!markdown

<h3 id="-first----last----single-">1.57 `First`, `Last`, `Single`</h3> <small><a href="#toc">Back to top</a></small>

- `TSource First()`, `TSource  First(Func<TSource, bool>)`
- `TSource Last()`, `TSource  Last(Func<TSource, bool>)`
- `TSource Single()`, `TSource  Single(Func<TSource, bool>)`

Wybiera odpowiednio pierwszy, ostatni i jedyny element speniajcy dany predykat. Jeli taki element nie istnieje, rzuca `InvalidOperationException`.
W przypadku `Single`, jeli istnieje wicej ni偶 jeden taki element, r贸wnie偶 rzuca `InvalidOperationException`.

Istniej warianty `FirstOrDefault`, `LastOrDefault`, `SingleOrDefault`, kt贸re nie rzucaj wyjtku w postaci nieznalezienia 偶adnego elementu, tylko zwracaj `default(TSource)`.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth"),
    new Duck("Psuchawrl")
};

var firstLong = ducks.First(d => d.Name.Length > 7);
Console.WriteLine(firstLong.Name);

#!markdown

<h3 id="-count-">1.58 `Count`</h3> <small><a href="#toc">Back to top</a></small>

Zwraca liczb element贸w. Tutaj w szczeg贸lnoci zwr贸my uwag na deferred execution.

#!csharp

var src = _repository.Ducks;
for(var i = 1; i <= src.Count(); ++i)
{
    /* ... */
}
for(var i = 1; i <= src.Count(); ++i)
{
    /* ... */
}

#!markdown

Powy偶szy kod powoduje dwa wykonania LINQ i jeli 藕r贸do danych nie zna swojej wielkoci, to mo偶emy zapaci dwa razy za przejrzenie caej zawartoci.

Dodatkowo u偶ywanie `Count` do sprawdzenia pustoci, czyli

#!csharp

var isEmpty = src.Count() == 0;

#!markdown

jest skrajnie nieinteligentne, bo mo偶e zaj czas liniowy od wielkoci kolekcji.

#!markdown

<h3 id="-all----any-">1.59 `All`, `Any`</h3> <small><a href="#toc">Back to top</a></small>

Sprawdza, czy predykat zachodzi dla ka偶dego/jakiegokolwiek elementu. Oczywicie nie jest gupie i breakuje wczenie jeli odpowied藕 jest ustalona.

#!csharp

var ducks = new List<Duck>
{
    new Duck("Jacu"),
    new Duck("Piotru"),
    new Duck("Azathoth"),
    new Duck("Psuchawrl")
};

var anyLongNames = ducks.Any(d => d.Name.Length > 8);
Console.WriteLine(anyLongNames);
var allLongNames = ducks.All(d => d.Name.Length > 8);
Console.WriteLine(allLongNames);

#!markdown

W C# pusto sprawdzamy `collection.Any()`.

#!markdown

<h2 id="materia-y">2. Materiay</h2> <small><a href="#toc">Back to top</a></small>

- Reszta tutoriala (Blazor i przykadowa aplikacja): https://mimuw.edu.pl/~mg394302/bd2021-csharp.html
- To repozytorium: https://github.com/V0ldek/CSharp-LightningCourse
